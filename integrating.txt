# Initialize multiple cars
NUM_CARS = 3  # Adjust the number of cars
cars = []
for i in range(NUM_CARS):
    car_rect = pygame.Rect(WIDTH // 2 + i * 50, HEIGHT - 100, car_width, car_height)  # Staggered start positions
    cars.append({
        "rect": car_rect,
        "speed": 2,
        "angle": 0,
        "waypoints": [],
        "parked": False
    })

def move_cars_along_paths(cars):
    """
    Moves multiple cars along their respective waypoints.
    Updates each car's status.
    """
    for car_data in cars:
        if car_data["parked"]:
            continue  # Skip parked cars
        
        # Get car properties
        car = car_data["rect"]
        waypoints = car_data["waypoints"]

        if not waypoints:
            car_data["parked"] = True  # No waypoints left; car is parked
            continue

        # Get the next waypoint
        next_waypoint = waypoints[0]
        car_center = car.center

        # Calculate distance to next waypoint
        dx = next_waypoint[0] - car_center[0]
        dy = next_waypoint[1] - car_center[1]
        distance = math.hypot(dx, dy)

        # If close enough to the waypoint, move to the next one
        if distance < 5:  # Threshold for reaching the waypoint
            waypoints.pop(0)
            if not waypoints:
                car_data["parked"] = True  # Mark as parked
            continue

        # Move the car towards the waypoint
        car.x += car_data["speed"] * dx / distance
        car.y += car_data["speed"] * dy / distance


def assign_targets_and_paths(cars, parking_spots):
    """
    Assign a parking target and compute paths for each car.
    """
    for car_data in cars:
        if car_data["parked"]:
            continue  # Skip parked cars

        # Find an unoccupied parking spot
        for spot in parking_spots:
            if not spot["occupied"]:
                target_slot = spot["rect"].center
                spot["occupied"] = True  # Mark the spot as occupied
                break

        # Compute the path to the target using A*
        start_pos = car_data["rect"].center
        path = a_star_with_obstacles(start_pos, target_slot, obstacles + non_drivable_areas)
        car_data["waypoints"] = path

while running:
    screen.fill(LIGHT_BLUE)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            print("QUIT event detected, exiting...", flush=True)
            running = False

    # Draw parking spots
    for spot in parking_spots:
        color = RED if spot["occupied"] else GREEN
        pygame.draw.rect(screen, color, spot["rect"])
        pygame.draw.rect(screen, BLACK, spot["rect"], 2)

    # Draw non-drivable areas
    for area in non_drivable_areas:
        pygame.draw.rect(screen, BLACK, area)

    # Draw obstacles
    for obstacle in obstacles:
        pygame.draw.rect(screen, (128, 0, 128), obstacle["rect"])  # Purple for obstacles

    # Draw dynamic cars
    move_dynamic_cars()
    for dcar in dynamic_cars:
        pygame.draw.rect(screen, YELLOW, dcar["rect"])

    # Assign targets and paths (initially or dynamically if needed)
    if not all(car["parked"] for car in cars):
        assign_targets_and_paths(cars, parking_spots)

    # Move all cars along their paths
    move_cars_along_paths(cars)

    # Draw cars
    for car_data in cars:
        car = car_data["rect"]
        rotated_car = pygame.transform.rotate(car_image, car_data["angle"])
        screen.blit(rotated_car, car.topleft)

    pygame.display.flip()
    clock.tick(60)
